import librosaimport numpy as npimport matplotlib.pyplot as pltimport waveimport mathpitches = dict([    (987.8, 'b5'),    (1047, 'c6'),    (1175, 'd6'),    (1319, 'e6'),    (1397, 'f6'),    (1568, 'g6'),    (1760, 'a6'),    (1976, 'b6'),    (2093, 'c7'),    (2349, 'd7'),])pitches_ranges = [    (1017.4, 'b5'),    (1111, 'c6'),    (1247, 'd6'),    (1358, 'e6'),    (1482.5, 'f6'),    (1664, 'g6'),    (1868, 'a6'),    (2034.5, 'b6'),    (2221, 'c7'),]def conv_duration_to_librosa_t(seconds):    return math.ceil(seconds * sr / 512)  # idk why this is 512 but it worksdef get_timings(frequencies, interval):    timings = []    t_interval = conv_duration_to_librosa_t(interval)    i = 0    while i < (len(frequencies) - t_interval):        if frequencies[i] == 0:            i += 1        else:            key = find_key(frequencies[i])            i += t_interval            timings.append((key, i))    return timingsdef find_key(pitch):    print(f"pitch: {pitch}")    if pitch < pitches_ranges[0][0] or pitch > pitches_ranges[-1][0]:        return None    else:        for i in range(1, len(pitches_ranges)):            if pitch < pitches_ranges[i][0]:                return pitches_ranges[i][1]def detect_pitch(magnitudes, pitches, t):    n = 100    indices = np.argpartition(magnitudes[:, t], -n)[-n:]    return pitches[min(indices), t]file_name = "data/scale3.wav"y, sr = librosa.load(file_name)spf = wave.open(file_name, 'r')signal = spf.readframes(-1)signal = np.frombuffer(signal, 'Int16')plt.figure()plt.grid()plt.plot(signal)pitches, magnitudes = librosa.piptrack(y=y, sr=sr, hop_length=None, n_fft=2048, threshold=0.75, fmin=987.8, fmax=2349)frequencies = []for t in range(np.size(pitches, 1)):    frequencies.append(detect_pitch(magnitudes, pitches, t))timings = get_timings(frequencies, 0.5)print(timings)